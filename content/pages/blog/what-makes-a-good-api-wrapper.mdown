date: 2009-11-16 09:06:56 -06:00
categories: blog

# What makes a good API wrapper?
As cool new <a href='http://www.programmableweb.com/apis/directory/1?protocol=REST&sort=date'>RESTful services</a> crop up practically each day, I find myself using or writing a lot of Ruby API wrappers. So much that I've seen some common approaches emerge, each with their own pros and cons.
<!--more-->

I had been considering this topic for some time when <a href='http://wynnnetherland.com/2009/11/a-new-ruby-gem-for-the-readernaut-api/#comment-23119279'>Zach's comment</a> on a <a href='http://wynnnetherland.com/2009/11/a-new-ruby-gem-for-the-readernaut-api/'>recent post</a> spurred me to write about it. Rattling around in the back of my head is <a href="http://chadfowler.com">Chad Fowler's</a> post from 2007 about <a href='http://github.com/mmangino/facebooker'>Facebooker</a> v. <a href="http://rfacebook.rubyforge.org/">RFacebook</a> and <a href='http://chadfowler.com/2007/9/5/writing-apis-to-wrap-apis'>writing APIs to wrap APIs</a>, so I'd like to start there.

<h3>Idiomatic consistency</h3>

Chad makes the case for idiomatic consistency with the language you're supporting. Put simply, this means your wrapper should smell like language in which it is written &mdash; Ruby like Ruby, Java like Java, PHP like PHP, and so on. This usually comes into play when language conventions bleed through an API in the form of method and variable names. Take the following example JSON response from the <a href='http://developer.billboard.com/'>Billboard Charts API</a>:

[javascript]
// http://api.billboard.com/apisvc/chart/v1/item?id=3064446&amp;format=json&amp;api_key=bvk4re5h37dzvx87h7rf5dqz
{&quot;chart&quot;:{
  &quot;issueDate&quot;:2006-03-04,
  &quot;description&quot;:&quot;Chart&quot;,
  &quot;chartItems&quot;:{
    &quot;firstPosition&quot;:1,
    &quot;totalReturned&quot;:15,
    &quot;totalRecords&quot;:25663,
    &quot;chartItem&quot;:[{
      &quot;songName&quot;:&quot;Lonely Runs Both Ways&quot;,
      &quot;artistName&quot;:&quot;Alison Krauss + Union Station&quot;,
      &quot;peek&quot;:1,
      &quot;catalogNo&quot;:&quot;610525&quot;,
      &quot;rank&quot;:1,
      &quot;exrank&quot;:1,
      &quot;weeksOn&quot;:65,
      &quot;albumId&quot;:655684,
    ...
}}
[/javascript]

Using the incredibly <a href='http://httparty.rubyforge.org'>simple and fun HTTParty gem</a> I can quite easily create a Ruby wrapper for this method that will return a <a href='http://www.intridea.com/2008/4/12/mash-mocking-hash-for-total-poser-objects?blog=company'>Mash</a> representing the data returned. However, when writing Ruby I prefer to deal with Ruby naming conventions, <code>chart.chart_items</code> instead of <code>chart.chartItems</code>. For this reason, when writing the <a href='http://github.com/squeejee/billboard'>Billboard wrapper gem</a> I implemented this trick:

[ruby]
class Hash
  
  # Converts all of the keys to strings, optionally formatting key name
  def rubyify_keys!
    keys.each{|k|
      v = delete(k)
      new_key = k.to_s.underscore
      self[new_key] = v
      v.rubyify_keys! if v.is_a?(Hash)
      v.each{|p| p.rubyify_keys! if p.is_a?(Hash)} if v.is_a?(Array)
    }
    self
  end
  
end
[/ruby]

Idiomatic consistency also means making method calls feel more natural. Take this example from the <a href='http://github.com/squeejee/upcoming-events'>Yahoo! Upcoming.com events wrapper:</a>

[ruby]
# from user.rb

# Retrieve the details about a user by email
# 
# +email+ (Required)
# The email of the user to look within. To run getInfoByEmail on multiple addresses, simply pass a comma-separated list of valid email addresses.
# 
def self.info_by_email(email)
  email = email.join(',') if email.is_a?(Array)
  Mash.new(self.get('/', :query =&gt; {:method =&gt; 'user.getInfoByEmail', :email =&gt; email}.merge(Upcoming.default_options))).rsp.user
end

[/ruby]

Two things make this method more Rubyish. <strong>First, change the method name to follow language conventions</strong>. The API method <code>user.getInfoByEmail</code> becomes <code>info_by_email</code>. This goes beyond just taking it from camel-casing to underscores. In this case, our domain model is <code>User</code> so the <code>user.</code> in the method name is redundant. I also dropped the <code>get</code> because most all the methods in the API have this prefix and dropping it reduces noise.

<strong>Second, provide convenience when possible. </strong> Note the highlighted line this time:

[ruby highlight="9"]
# from user.rb

# Retrieve the details about a user by email
# 
# +email+ (Required)
# The email of the user to look within. To run getInfoByEmail on multiple addresses, simply pass a comma-separated list of valid email addresses.
# 
def self.info_by_email(email)
  email = email.join(',') if email.is_a?(Array)
  Mash.new(self.get('/', :query =&gt; {:method =&gt; 'user.getInfoByEmail', :email =&gt; email}.merge(Upcoming.default_options))).rsp.user
end

[/ruby]

The API method supports returning info for multiple users from a comma delimited list of email addresses. Instead of making the consumer build that list and concatenate a string of delimited email addresses, we can accept either a string or an array and build the list for them if need be.

<h3>Wrapping vs. Abstraction</h3>

Another design decision in writing a good API wrapper is between writing a wrapper and an abstraction. Take these examples of updating a your Twitter status from popular Ruby wrappers for the API:

<h5><a href='http://github.com/mbleigh/twitter-auth'>Twitter Auth</a> from <a href='http://twitter.com/mbleigh'>@mbleigh</a> </h5>
[ruby]
user.twitter.post('/statuses/update.json', 'status' =&gt; 'This is my status.')
[/ruby]

<h5><a href='http://github.com/hayesdavis/grackle'>Grackle</a> from <a href='http://twitter.com/hayesdavis'>@hayesdavis</a> </h5>
[ruby]
client.statuses.update.json! :status=&gt;'this status is from grackle'
[/ruby]

<h5><a href='http://github.com/jnunemaker/twitter'>Twitter</a> from <a href='http://twitter.com/jnunemaker'>@jnunemaker</a> </h5>
[ruby]
client.update('Heeeeyyyyooo from the Twitter Gem')
[/ruby]

Michael and Hayes lean more to the simple wrapper side of the spectrum while John provides a simple abstraction and the caller doesn't know or care about the underlying API call at all. Each approach has its advantages and disadvantages.

<h4>When wrapping is preferable</h4>

In my experience, simple API wrappers provide two advantages:

<ul>
  <li><strong>Service API changes require less changes in the wrapper.</strong> In all three examples, if Twitter decided to add additional parameters, the library could handle the change without an update to the wrapper. However, if Twitter decided to rename the API method (which has happened) we would have to update the Twitter gem in the last example. </li>
  <li><strong>You can leverage existing API documentation.</strong> In the first two examples, it's very clear which REST endpoint is in play, so it's very easy to find the method in the <a href='http://apiwiki.twitter.com'>Twitter API docs</a> to see what parameters are supported.</li>
</ul>

<h4>When abstraction makes sense</h4>

Abstraction, on the other hand, provides some advantages as well:

<ul>
  <li><strong>Simplifying a complex API.</strong> <a href='http://upcoming.yahoo.com/services/api/'>Some APIs</a> provide a long, flat surface area. Abstracting and organizing those methods into classes is natural.</li>
  <li><strong>Provide a business domain.</strong> Abstraction can also provide things like caching, lazy loading of associated data, and simple methods that may make multiple calls to the server.</li>
</ul>

<h3>Take advantage of your language</h3>

In either case, when creating a simple wrapper or abstraction library for an API, take advantage of the language in which your implementing. 
Let's compare the simple wrappers in the first two examples. Both perform a <code>POST</code> to the <code>/statuses/update</code> method:

[ruby]
# twitter-auth
user.twitter.post('/statuses/update.json', 'status' =&gt; 'This is my status.')

# grackle
client.statuses.update.json! :status=&gt;'this status is from grackle'
[/ruby]

I rather like what Hayes has done with some <a href='http://ruby-doc.org/core/classes/Kernel.html#M005925'><code>method_missing</code></a> magic in the second example. By using dot notation, I have to worry about less string building.

Similarly, I really dig what John did in his implementation of Twitter search in the Twitter gem:

[ruby]
Twitter::Search.new.from('jnunemaker').to('pengwynn').hashed('ruby').fetch()
[/ruby]

That's a very natural way of specifying parameters without having to build a params hash before or during the method call. I liked it so much I ripped it off when creating the <a href='http://github.com/squeejee/remixr'>Rimxr</a> gem, a wrapper for the <a href='http://remix.bestbuy.com/docs'>BestBuy Remix API</a>:

[ruby]
# calls http://api.remix.bestbuy.com/v1/stores(area(76227,50))+products(salePrice&lt;=3000)?apiKey=OU812
stores = client.stores({:area =&gt; ['76227', 50]}).products({:salePrice =&gt; {'$gt' =&gt; 3000}}).fetch.stores

[/ruby]

Using the power of Ruby to support chaining methods lets us build some powerful queries quite simply.

<h4>Summary</h4>

There are many considerations in designing an API wrapper, but it's important to make the library feel as natural as possible in the language in which it's written. With many APIs, there's room for multiple successful libraries. What are your thoughts? What are some of your favorite API wrappers and what makes them special?
